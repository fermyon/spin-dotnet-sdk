#include <stdlib.h>
#include <string.h>

#include <mono-wasi/driver.h>
#include <mono/metadata/assembly.h>
#include <mono/metadata/class.h>
#include <mono/metadata/appdomain.h>
#include <mono/metadata/image.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/object.h>
#include <mono/metadata/debug-helpers.h>
#include <mono/metadata/reflection.h>
#include <mono/utils/mono-publib.h>

#include "./util.h"

// These are generated by the WASI SDK during build
const char* dotnet_wasi_getentrypointassemblyname();
const char* dotnet_wasi_getbundledfile(const char* name, int* out_length);
void dotnet_wasi_registerbundledassemblies();

set_member_err_t set_property(MonoClass* klass, MonoObject* instance, const char* name, void* value) {
    MonoProperty* prop = mono_class_get_property_from_name(klass, name);
    if (!prop) {
        return SET_MEMBER_ERR_NOT_FOUND;
    }
    MonoMethod* setter = mono_property_get_set_method(prop);
    if (!setter) {
        return SET_MEMBER_ERR_READONLY;
    }

    MonoObject* exn = NULL;
    void* args[1];
    args[0] = value;
    mono_wasm_invoke_method(setter, instance, args, &exn);

    mono_free(prop);
    mono_free(setter);

    if (exn) {
        return SET_MEMBER_ERR_EXCEPTION;
    }
    return SET_MEMBER_ERR_OK;
}

set_member_err_t set_field(MonoClass* klass, MonoObject* instance, const char* name, void* value) {
    MonoClassField* field = mono_class_get_field_from_name(klass, name);
    if (!field) {
        return SET_MEMBER_ERR_NOT_FOUND;
    }
    mono_field_set_value(instance, field, value);
    return SET_MEMBER_ERR_OK;
}

void get_field(MonoClass* klass, MonoObject* instance, const char* name, void* receiver) {
    MonoClassField* field = mono_class_get_field_from_name(klass, name);
    mono_field_get_value(instance, field, receiver);
}

resolve_err_t find_decorated_method(MonoAssembly* assembly, const char* attr_name, MonoMethod** decorated_method) {
    MonoImage* image = mono_assembly_get_image(assembly);
    if (!image) {
        return RESOLVE_ERR_IMAGE_NOT_RESOLVED;
    }

    const MonoTableInfo* table_info = mono_image_get_table_info(image, MONO_TABLE_TYPEDEF);
    if (!table_info) {
        return RESOLVE_ERR_TYPEDEF_TABLE_NOT_RESOLVED;
    }

    int rows = mono_table_info_get_rows(table_info);

    for (int i = 0; i < rows; i++) 
    {
        uint32_t cols[MONO_TYPEDEF_SIZE];
        mono_metadata_decode_row(table_info, i, cols, MONO_TYPEDEF_SIZE);

        const char* name = mono_metadata_string_heap(image, cols[MONO_TYPEDEF_NAME]);
        const char* name_space = mono_metadata_string_heap(image, cols[MONO_TYPEDEF_NAMESPACE]);
        if (!name || !name_space) {
            continue; 
        }

        MonoClass* klass = mono_class_from_name(image, name_space, name);
        if (!klass) {
            continue;
        }

        void* iter = NULL;
        MonoMethod* method;
        while ((method = mono_class_get_methods(klass, &iter)) != NULL)
        {
            MonoCustomAttrInfo* attr_info = mono_custom_attrs_from_method(method);
            if (attr_info) {
                for (int i = 0; i < attr_info->num_attrs; ++i) {
                    char* attr_ctor_name = mono_method_full_name(attr_info->attrs[i].ctor, 1);
                    if (strstr(attr_ctor_name, attr_name) != NULL) {
                        *decorated_method = method;
                        return RESOLVE_ERR_OK;
                    }
                    mono_free(attr_ctor_name);
                }
                mono_free(attr_info);
            }
            mono_free(method);
        }

        mono_free(klass);
    }

    return RESOLVE_ERR_NO_MATCH;
}

entry_points_err_t find_entry_points(const char* attr_name, const char* interop_helper_name, MonoMethod** handler, MonoClass** interop_helper_class, MonoImage** sdk_dll_image) {
    MonoAssembly* assembly = mono_assembly_open(dotnet_wasi_getentrypointassemblyname(), NULL);
    if (!assembly) {
        return EP_ERR_NO_ENTRY_ASSEMBLY;
    }

    MonoMethod* method;
    resolve_err_t find_err = find_decorated_method(assembly, attr_name, &method);
    if (find_err) {
        return EP_ERR_NO_HANDLER_METHOD;
    }

    MonoMethodSignature* signature = mono_method_signature(method);
    if (!signature) {
        return EP_ERR_NO_SIGNATURE;
    }

    // Assume for now only one param and of the right type
    void* iter = NULL;
    MonoType* request_type = mono_signature_get_params(signature, &iter);
    if (!request_type) {
        return EP_ERR_NO_PARAM_TYPE;
    }

    MonoClass* request_class = mono_type_get_class(request_type);
    if (!request_class) {
        return EP_ERR_NO_REQUEST_CLASS;
    }

    MonoImage* sdk_image = mono_class_get_image(request_class);
    if (!sdk_image) {
        return EP_ERR_NO_SDK_IMAGE;
    }

    MonoClass* interop_class = mono_class_from_name(sdk_image, "Fermyon.Spin.Sdk", interop_helper_name);
    if (!interop_class) {
        return EP_ERR_NO_INTEROP_HELPER_CLASS;
    }

    *handler = method;
    *interop_helper_class = interop_class;
    *sdk_dll_image = sdk_image;

    return EP_ERR_OK;
}
